param (
	[string]$UserName = ''
)

if ($UserName) {
	$textboxSearch.Text = $UserName
}

[System.Collections.ArrayList]$searchTargets   = 'Username','VM Name','Endpoint Name','Endpoint IP','LaunchedViaHostname','LaunchedViaIPAddress'
[System.Collections.ArrayList]$searchOperators = 'equals','contains'
$comboboxSearchTarget.DataSource = $searchTargets
$comboboxOperator.DataSource     = $searchOperators
$script:enumGuessWarnings = @()
$script:needScopeWarning = $true
$script:defaultProperties = @(
	'Site',
	'dg_Name',
	'u_FullName',
	'u_UserName',
	'vm_HostedMachineName',
	'con_ClientName',
	'con_ClientAddress',
	'con_LaunchedViaHostname',
	'con_ConnectedViaHostname',
	'ses_CreatedDate',
	'ses_EndDate',
	'con_IsReconnect',
	'ConnectedNow',
	'ses_ConnectionState',
	'con_BrokeringDate',
	'con_ClientSessionValidateDate',
	'con_ServerSessionValidateDate',
	'con_EstablishmentDate',
	'ses_FailureDate',
	'ses_FailureReason',
	'con_DisconnectDate',
	'ses_ConnectionStateChangeDate',
	'con_InteractiveStartDate',
	'con_InteractiveEndDate',
	'con_ProfileLoadStartDate',
	'con_ProfileLoadEndDate',
	'con_GpoStartDate',
	'con_GpoEndDate',
	'con_LogonScriptsStartDate',
	'con_LogonScriptsEndDate',
	'con_InteractiveStartDate',
	'con_InteractiveEndDate',
	'ses_CurrentConnectionId',
	'con_Id',
	'con_Protocol'
)
$script:FormLoaded = $false
$script:cancelSearch = $false
$script:ddcLookup = @{
	'VDI'    = @('ctxddc01','sltctxddc01')
	'XenApp' = @('ctxxaddc01','sltctxxaddc01')
}

Add-PSSnapin Citrix.Broker.Admin.V2

#region Andy's functions
function Get-CtxMonitorEnumerator
#------------------------------------------------------------------------
{
<#
.SYNOPSIS
	Performs discovery on the Citrix Monitor OData API's enum data types.

.DESCRIPTION
	Easier to explain this with examples. It's basically a way to get
	the enums from OData into something readable/usable in PowerShell.

.EXAMPLE
	Get-CtxMonitorEnumerator -DDC ctxddc01 -DataType DesktopKind -Value Shared

	Inspects the 'DesktopKind' data type and returns the int32 value that means 'Shared'.

.EXAMPLE
	Get-CtxMonitorEnumerator -DDC ctxddc01 -DataType ConnectionState

	Inspects the 'ConnectionState' data type and returns a hashtable with all of the
	possible string:int32 pairs.

.EXAMPLE
	Get-CtxMonitorEnumerator -DDC ctxddc01 -Detailed

	Lists all enumerator data types in the Monitor API, along with descriptors for each.
#>
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[string]$DDC,

		[switch]$Detailed,
		
		[string]$DataType = $null,
		
		[int32]$Value
	)
	
	begin {
		if ($DataType) {
			try	{
				[Uri]$lookupUri = "http://$DDC/Citrix/Monitor/Odata/v1/Methods/GetAllMonitoringEnums('$DataType')/Values"
				[Xml.XmlElement[]]$enumValues = Invoke-RestMethod -UseDefaultCredentials -Uri $lookupUri -ErrorAction Stop
			}
			catch { throw $_.Exception.Message }
		}
		else {
			[Uri]$lookupUri = "http://$DDC/Citrix/Monitor/Odata/v1/Methods/GetAllMonitoringEnums"
			[Xml.XmlElement[]]$enums = Invoke-RestMethod -UseDefaultCredentials -Uri $lookupUri -ErrorAction Stop
		}
	}
	
	process {
		# Discover all the enum data types?
		if (!$DataType)
		{
			[Uri]$lookupUri = "http://$DDC/Citrix/Monitor/Odata/v1/Methods/GetAllMonitoringEnums"
			[Xml.XmlElement[]]$enums = Invoke-RestMethod -UseDefaultCredentials -Uri $lookupUri -ErrorAction Stop
			
			foreach ($enum in $enums)
			{
				$typeName = $enum.content.properties.TypeName
				if ($Detailed)
				{
					Write-Output "`n// $typeName //"
					Get-CtxMonitorEnumerator -DDC $DDC -DataType $typeName
				}
				else
				{
					Write-Output $typeName
				}
			}
			return
		}
		
		# Look up a specific data type

		if (!$enumValues) { throw [ArgumentOutOfRangeException]'DataType' }
		else 
		{
			$enumLookup = @{}
			foreach ($enumValue in $enumValues)
			{
				[string]$name = $enumValue.content.properties.Name
				[int]$index   = $enumValue.content.properties.Value.FirstChild.Value
				$enumLookup[$index] = $name
			}
			
			# If an entry was specified, try returning the corresponding name.
			if ($Value)
			{
				if ($enumLookup[$Value])
				{
					return $enumLookup[$Value]
				}
				else
				{
					Write-Error "Valid $DataType selections: $($enumLookup.Keys -join ', ')"
					throw [ArgumentOutOfRangeException]'Value'
				}
			}
			# Otherwise, return a hashtable describing the data type
			else { return $enumLookup }
		}
	}
}

function Convert-Properties
{
	[CmdletBinding()]
	param(
		[Parameter(Mandatory)]
		[object]$InputObject,
	
		[string]$Prefix = '',
	
		[string]$Separator = '_'
	)
	
	process {
		$newObject = New-Object PSObject
		
		# Renaming properties?
		if ($Prefix) {
			$Prefix = "${Prefix}${Separator}"
		}			

		foreach ($member in $(Get-Member -MemberType 'NoteProperty' -InputObject $InputObject)) {

			# Keep any direct object properties
			if ($member.Definition -notmatch "^System.Management.Automation.PSCustomObject") {
				$memberName = $member.Name
				$value      = $InputObject.$memberName
				
				# Inspect non-null property values and convert where appropriate
				if (($null -ne $value)) {
					
					# Translate enums
					if ($value.GetType().Name -match 'Int') {
						
						# First, we'll check for mildly obscure references and deal with those
						if (($memberName -eq 'ExitCode') -and $ctxEnumLookup.SessionFailureCode[$value]) {
							$memberName = 'FailureReason'
							$value = $ctxEnumLookup.SessionFailureCode[$value]
						}
						
						# Otherwise, look for exact matches in the known enums
						elseif ($memberName -in $ctxEnums) {
							if ($ctxEnumLookup.$memberName[$value]) { 
								$value = $ctxEnumLookup.$memberName[$value]
							}
							else { 
								Write-Warning "Enum lookup error for '$memberName'! $($_.Exception.Message)" 
							}
						}
						
						# No exact match, but most int32s are an enum, and the original datatype gets lost in the JSON conversion, so we'll look harder...
						else {
							$foundMatch = $false
							$i = 0
							
							# Many property names will have names like "Current<NameOfEnum>" or they'll only refer to part
							# of the enum name (e.g. "FaultState" property with "MachineFaultStateCode" values), so we'll loop
							# through each of the known enums and compare it to our current property name
							while (!$foundMatch -and ($i -lt ($ctxEnums.Length -1))) {
								$ctxEnum = $ctxEnums[$i]
								$i++
								
								# Is this enum is a substring of the property name, or vice versa? 
								if (($memberName -match $ctxEnum) -or ($ctxEnum -match $memberName)) {
								
									# Yep, does the value translate? 
									if ($ctxEnumLookup.($ctxEnum)[$value]) {
										
										# Yep. Recast to string and translate. 
										$message    = "Assuming the auto-converted JSON $($value.GetType().Name) values in property '$memberName' refer to the '$ctxEnum' Citrix monitor enum. Recasting as string and translating."
										$value      = $ctxEnumLookup.($ctxEnum)[$value]
										$foundMatch = $true
																				
										# Warn about each enum guess (once per script run).
										if ($message -notin $enumGuessWarnings) {
											Write-Warning $message
											$script:enumGuessWarnings += $message
										} 
																				
									} # if (value translates)
								} # if (approximate match)
							} # while (still guessing)
						} # if (no exact match)
					} # if (translating enum)
										
					# Convert back to localtime
					elseif ($value.GetType() -eq [DateTime]) {
						$value = $value.ToLocalTime()
					}
					
				} # if (inspecting property value)
				
				$newObject | Add-Member -MemberType 'NoteProperty' -Name "${Prefix}${memberName}" -Value $value
				
			} # if (direct property)
		} # foreach
		
		# Return the new object
		$newObject
		
	} # process
}

function Lock-Controls {

	# Disable scoping inputs
	$formMain.Cursor = 'WaitCursor'
	$buttonSearch.Enabled = $false
	$comboboxOperator.Enabled = $false
	$comboboxResourceType.Enabled = $false
	$comboboxSearchTarget.Enabled = $false
	$textboxSearch.ReadOnly = $true
	$dtpMin.Enabled = $false
	$dtpMax.Enabled = $false
	$checkboxFullDetails.Enabled = $false
	
	# Enable interrupt/progress controls
	$script:cancelSearch = $false
	$buttonCancelSearch.Enabled = $true
	$buttonCancelSearch.Focus()
	$buttonCancelSearch.Cursor = 'Arrow'
	$progressbaroverlaySearch.Value = 15 > $null
	$progressbaroverlaySearch.Style = 'Marquee'
	$progressbaroverlaySearch.Show()
	$labelProgress.Show() 
}

function Unlock-Controls {

	# Disable interrupt/progress controls
	$progressbaroverlaySearch.Hide()
	$labelProgress.Hide()
	$buttonCancelSearch.Enabled = $false

	# Enable scoping inputs
	$buttonSearch.Enabled = $true
	$comboboxOperator.Enabled = $true
	$comboboxResourceType.Enabled = $true
	$comboboxSearchTarget.Enabled = $true
	$textboxSearch.ReadOnly = $false
	$dtpMin.Enabled = $true
	$dtpMax.Enabled = $true
	$checkboxFullDetails.Enabled = $true
	$formMain.Cursor = 'Default'
}

function Get-Connections
#------------------------------------------------------------------------
# Grab connection logs from a DDC 
{
	[CmdletBinding()]
	[OutputType([object[]])]
	param
	(
		[Parameter(Mandatory)]
		[string]$DDC,
		
		[Parameter(Mandatory)]
        [Alias('ModifiedDate')]
		[datetime]$ModifiedDateMin,

        [Parameter()]
        [datetime]$ModifiedDateMax = $(Get-Date),
        
        [Parameter(Mandatory)]
        [string]$SearchString,
	
		[Parameter(Mandatory)]
		[ValidateSet('UserName','HostedMachineName','ClientName','ClientAddress','LaunchedViaHostname','LaunchedViaIPAddress')]
		[string]$SearchType,
		
        [switch]$ExactMatch = $true
	)
	
	$labelProgress.Text = "Searching connections on $($DDC.ToUpper())"

    # Grab the Citrix site name so we can squirt it in as a custom property.
    try   { $siteName = (Get-BrokerSite -AdminAddress $DDC -ErrorAction Stop).Name }
    catch { $siteName = 'Unknown' }

    # Same deal with the DDC FQDN
    try   { $ddcFqdn = (Resolve-DnsName -Name $DDC -ErrorAction Stop | Select-Object -First 1).Name }
    catch { $ddcFqdn = $DDC }

	# General query setup
    [string]$ModifiedDateMinUTC = Get-Date -Date $ModifiedDateMin.ToUniversalTime() -Format 'yyyy\-MM\-dd\THH\:mm\:ss'
    [string]$ModifiedDateMaxUTC = Get-Date -Date $ModifiedDateMax.ToUniversalTime() -Format 'yyyy\-MM\-dd\THH\:mm\:ss'
    $connectionPath   = "http://$DDC/Citrix/Monitor/Odata/v1/Data/Connections()"
	$connectionExpand = '&$expand=Session,Session/User,Session/Machine,Session/Machine/Catalog,Session/Machine/DesktopGroup'
    $connectionFilter = "(ModifiedDate gt datetime'$ModifiedDateMinUTC')","(ModifiedDate le datetime'$ModifiedDateMaxUTC')"
	
	# Customize query based on related entity ...
	switch ($SearchType) {
		'UserName'           { $relatedEntity = 'Session/User/UserName' }
		'HostedMachineName'  { $relatedEntity = 'Session/Machine/HostedMachineName' }
		default              { $relatedEntity = $SearchType }
	}

	# ... and search operator
    if ($ExactMatch) {	
		# if it's an equality search, we'll interpret comma characters as logical "or"s
		$subExpression = ''
		foreach ($searchToken in $($SearchString -split ',')) {
			
			$searchToken = $searchToken.Trim()
			
			# Prefix everything but the first element in the subexpression with " or " 
			if ($subExpression) { $operator = ' or ' }
			else                { $operator = '' }
			$subExpression += "${operator}(${relatedEntity} eq '${searchToken}')"
		}
		$connectionFilter += "(${subExpression})" 
	}
    else { 
		$connectionFilter += "substringof('$SearchString', $relatedEntity)" 
	}
	
	# Finalize and execute query
	try	{
		$queryStart = Get-Date
		[Uri]$connectionsUri = $connectionPath + '?$filter=' + $($connectionFilter -join ' and ') + $connectionExpand
		Write-Warning $connectionsUri.AbsoluteUri
		$connections = Invoke-JsonRequest -Url $connectionsUri -UseDefaultCredentials:$true -ErrorAction Stop
	}
	catch {
		[System.Windows.Forms.Messagebox]::Show($_.Exception.Message, 'JSON Request Error', 'OK', 'Error')
		Write-Error $_.Exception.Message
		return
	}
	finally {
		[int]$queryElapsed = ((Get-Date) - $queryStart).TotalSeconds
		Write-Warning "Query duration: $queryElapsed seconds."
	}
	
	$i = 0
	$resultCount = $connections.d.Length
	$labelProgress.Text = "Translating and flattening ${resultCount} records from $($DDC.ToUpper())"
	$progressbaroverlaySearch.Value = 1
	$progressbaroverlaySearch.Style = 'Continuous'
	
	# Create a collection of connections as flat PSObjects with translated enums and all sorts of properties
	$megaConnections = foreach ($connection in $connections.d) {
		
		$i++
		$pctComplete = [math]::Round(100 * $i / $resultCount)
		$progressbaroverlaySearch.Value = $pctComplete
		
		[System.Windows.Forms.Application]::DoEvents()
		
		if ($script:cancelSearch -eq $true) {
			$progressbaroverlaySearch.Value = 0
			$progressbaroverlaySearch.Hide()
			$labelProgress.Hide()
			break
		}
		
		# Recurse through some interesting properties on the $connection object and 
		# create a few (flat) mini-objects, so we can put them all together in a useable gridview
		$connectionData   = Convert-Properties -Prefix 'con' -InputObject $connection 
		$sessionData      = Convert-Properties -Prefix 'ses' -InputObject $connection.Session
		$userData         = Convert-Properties -Prefix 'u'   -InputObject $connection.Session.User
		$machineData      = Convert-Properties -Prefix 'vm'  -InputObject $connection.Session.Machine
		$catalogData      = Convert-Properties -Prefix 'cat' -InputObject $connection.Session.Machine.Catalog
		$desktopGroupData = Convert-Properties -Prefix 'dg'  -InputObject $connection.Session.Machine.DesktopGroup
		
		$flatObjects    = @($connectionData, $sessionData, $userData, $machineData, $catalogData, $desktopGroupData)
		$megaConnection = New-Object PSObject
				
		# Aggregate the properties from the mini-objects into a single flattened connection object
		foreach ($flatObject in $flatObjects) {
			foreach ($property in $flatObject.PSObject.Properties) {
				$megaConnection | Add-Member -MemberType 'NoteProperty' -Name $property.Name -Value $property.Value 
			}
		}
		$megaConnection
	}

	# return the detailed connection log collection, and squirt in a couple final properties
	$megaConnections | Select-Object -Property @{n='Site';e={$siteName}},`
	                                           @{n='AdminAddress';e={$ddcFqdn}},`
	                                           @{n='ConnectedNow';e={($_.ses_CurrentConnectionId -eq $_.con_Id) -and ($_.ses_ConnectionState -in 'Connected','Active')}},*
}

function Invoke-JsonRequest
{
	[CmdletBinding()]
	param(
		[Parameter(Mandatory=$True)]
		[string]$Url,

		[Parameter(Mandatory=$False)]
		[System.Net.ICredentials]$Credentials,

		[Parameter(Mandatory=$False)]
		[bool]$UseDefaultCredentials = $True,

		[Parameter(Mandatory=$False)]
		[Microsoft.PowerShell.Commands.WebRequestMethod]$Method = [Microsoft.PowerShell.Commands.WebRequestMethod]::Get 
	)

	$result = $null
	$client = New-Object System.Net.WebClient
	
	if ($Credentials) { 
		$client.Credentials = $Credentials
	}
	elseif ($UseDefaultCredentials) {
		$client.Credentials = [System.Net.CredentialCache]::DefaultCredentials 
	}
	
	$client.Headers.Add("Content-Type", "application/json;odata=verbose")
	$client.Headers.Add("Accept", "application/json;odata=verbose")
	$rawText = $client.DownloadString($Url)
	$client.Dispose()
		
	try {
		# Try to parse this the "right" way
		$result = $rawText | ConvertFrom-Json -ErrorAction Stop
	}
	catch {
		$prevText = $statusbarMain.Text
		$statusbarMain.Text = "[WARNING: Falling back to slow JSON parser due to large payload. Update to PSv5 to fix.] ${prevText}"
		
		# Slow (but functional) workaround for older versions of ConvertFrom-Json (pre-PSv5) that can't parse more than 2 MB.
		[void][System.Reflection.Assembly]::LoadWithPartialName("System.Web.Extensions")
		$jsonSerializer = New-Object -TypeName System.Web.Script.Serialization.JavaScriptSerializer 
		$jsonSerializer.MaxJsonLength = [int32]::MaxValue
		$result = ParseItem (($jsonSerializer).DeserializeObject($rawText))
		$rawText = $null
		$jsonSerializer = $null		
	}
	
	$result
	
}

function ParseItem($jsonItem) 
{
    if($jsonItem.PSObject.TypeNames -match 'Array') 
    {
        return ParseJsonArray($jsonItem)
    }
    elseif($jsonItem.PSObject.TypeNames -match 'Dictionary') 
    {
        return ParseJsonObject([HashTable]$jsonItem)
    }
    else 
    {
        return $jsonItem
    }
}

function ParseJsonObject($jsonObj) 
{
    $result = New-Object -TypeName PSCustomObject
    foreach ($key in $jsonObj.Keys) 
    {
        $item = $jsonObj[$key]
        if ($item) 
        {
            $parsedItem = ParseItem $item
        }
        else 
        {
            $parsedItem = $null
        }
        $result | Add-Member -MemberType NoteProperty -Name $key -Value $parsedItem
    }
    return $result
}

function ParseJsonArray($jsonArray) 
{
    $result = @()
    $jsonArray | ForEach-Object -Process {
        $result += , (ParseItem $_)
    }
    return $result
}

function ParseJsonString($json) 
{
    $config = $javaScriptSerializer.DeserializeObject($json)
    return ParseJsonObject($config)
}

#endregion


function Refresh-Form
{
	[CmdletBinding()]
	param(
		[int]$MinAmbiguousSearchLength = 5
	)
	$refreshBegin = Get-Date
	Lock-Controls
	Clear-Results
	Write-Warning "Calling Refresh-Form"

	if (($comboboxOperator.SelectedItem -eq 'contains') -and ($textboxSearch.Text.Length -lt $MinAmbiguousSearchLength)) {
		[System.Windows.Forms.Messagebox]::Show("Ambiguous search requires at least $MinAmbiguousSearchLength chars.", 'Invalid Search String', 'OK', 'Error')
	}

	elseif ($textboxSearch.Text) {
		
		# Set search filters
		switch ($comboboxSearchTarget.SelectedItem) {
			'Username'      { $searchType = 'UserName'}
			'VM Name'       { $searchType = 'HostedMachineName' }
			'Endpoint Name' { $searchType = 'ClientName' }
			'Endpoint IP'   { $searchType = 'ClientIP' }
			default         { $searchType = $comboboxSearchTarget.SelectedItem }
		}
		switch ($comboboxOperator.SelectedItem) {
			'equals'   { $exactMatch = $true }
			'contains' { $exactMatch = $false }
			default    { $exactMatch = $null }
		}
		
		# Search connection logs
		$connectionLogs = @()
		if (($searchType -ne $null) -and ($exactMatch -ne $null)) {
			$ddcs = $ddcLookup[$comboboxResourceType.SelectedItem]
			$i = 0
			$script:cancelSearch = $false
			foreach ($ddc in $ddcs) {
				if ($script:cancelSearch -eq $true) {
					$progressbaroverlaySearch.Value = 0
					$progressbaroverlaySearch.Hide()
					$labelProgress.Hide()
					break
				}
				$i++
				$statusbarMain.Text = "Retrieving connections from site ${i} of $($ddcs.Length) ..."
				$connectionLogs += Get-Connections -ExactMatch:$exactMatch -SearchString $textboxSearch.Text -SearchType $searchType -DDC $ddc -ModifiedDateMin ($dtpMin.Value).Date -ModifiedDateMax ($dtpMax.Value).Date.AddDays(1).AddMilliseconds(-1)
			}
		}
		
		# If we have logs, load them into the data grid view
		if ($connectionLogs) {
			$script:connectionLogs = $connectionLogs 
			$connectionLogsTable = ConvertTo-DataTable -InputObject $connectionLogs
			Write-Warning "Log table has $($connectionLogsTable.Rows.Count) rows and $($connectionLogsTable.Columns.Count) columns."
			Load-DataGridView -DataGridView $datagridviewResults -Item $connectionLogsTable
			Update-TableLayout
			$buttonExportCSV.Enabled = $true
		}
		else {
			$script:connectionLogs = $null
		}
	}
	$refreshEnd = Get-Date
	$refreshElapsed = ($refreshEnd - $refreshBegin)
	if ($script:cancelSearch) {
		$disclaimer = 'Search cancelled! '
	}
	else {
		$disclaimer = ''
	}
	
	if ($connectionLogs -or $textboxSearch.Text) {
		$statusbarMain.Text = "${disclaimer}$($connectionLogs.Length) results found in $([Math]::Round($refreshElapsed.TotalSeconds, 2)) seconds."
	}
	else {
		$statusbarMain.Text = $disclaimer
	}
	
	Unlock-Controls
}

function Update-TableLayout {
	if ($datagridviewResults.Rows) {
		Write-Warning "Updating table layout"
		# Stick the default properties at the beginning and sort by decending brokering date
		$i = 0
		foreach ($defaultProperty in $defaultProperties) {
			$datagridviewResults.Columns[$defaultProperty].DisplayIndex = $i
			$i++
		}
		$sortCol = $datagridviewResults.Columns['con_BrokeringDate']
		$datagridviewResults.Sort($sortCol, 'Descending')
		
		if ($checkboxFullDetails.Checked) {
			foreach ($column in $datagridviewResults.Columns) {
				$column.Visible = $true
			}
		}
		else {
			foreach ($column in $datagridviewResults.Columns) {
				if ($column.Name -notin $DefaultProperties) {
					$column.Visible = $false
				}
				else {
					$column.Visible = $true
				}
			}
		}
		
		foreach ($column in $datagridviewResults.Columns) {
			if ($column.ValueType -eq [DateTime]) {
				$column.DefaultCellStyle.Format = "MM/dd/yyyy hh:mm:ss tt"
			}
		}
		
		$datagridviewResults.AutoResizeColumns()
	}
}

function Clear-Results {
	$datagridviewResults.DataSource = $null
	$datagridviewResults.Refresh()
	$buttonExportCSV.Enabled = $false
}

#region Control Helper Functions
function Load-ComboBox 
{
<#
	.SYNOPSIS
		This functions helps you load items into a ComboBox.

	.DESCRIPTION
		Use this function to dynamically load items into the ComboBox control.

	.PARAMETER  ComboBox
		The ComboBox control you want to add items to.

	.PARAMETER  Items
		The object or objects you wish to load into the ComboBox's Items collection.

	.PARAMETER  DisplayMember
		Indicates the property to display for the items in this control.
	
	.PARAMETER  Append
		Adds the item(s) to the ComboBox without clearing the Items collection.
	
	.EXAMPLE
		Load-ComboBox $combobox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Load-ComboBox $combobox1 "Red" -Append
		Load-ComboBox $combobox1 "White" -Append
		Load-ComboBox $combobox1 "Blue" -Append
	
	.EXAMPLE
		Load-ComboBox $combobox1 (Get-Process) "ProcessName"
#>
	Param (
		[ValidateNotNull()]
		[Parameter(Mandatory=$true)]
		[System.Windows.Forms.ComboBox]$ComboBox,
		[ValidateNotNull()]
		[Parameter(Mandatory=$true)]
		$Items,
	    [Parameter(Mandatory=$false)]
		[string]$DisplayMember,
		[switch]$Append
	)
	
	if(-not $Append)
	{
		$ComboBox.Items.Clear()	
	}
	
	if($Items -is [Object[]])
	{
		$ComboBox.Items.AddRange($Items)
	}
	elseif ($Items -is [Array])
	{
		$ComboBox.BeginUpdate()
		foreach($obj in $Items)
		{
			$ComboBox.Items.Add($obj)	
		}
		$ComboBox.EndUpdate()
	}
	else
	{
		$ComboBox.Items.Add($Items)	
	}

	$ComboBox.DisplayMember = $DisplayMember	
}

function Load-DataGridView
{
	<#
	.SYNOPSIS
		This functions helps you load items into a DataGridView.

	.DESCRIPTION
		Use this function to dynamically load items into the DataGridView control.

	.PARAMETER  DataGridView
		The ComboBox control you want to add items to.

	.PARAMETER  Item
		The object or objects you wish to load into the ComboBox's items collection.
	
	.PARAMETER  DataMember
		Sets the name of the list or table in the data source for which the DataGridView is displaying data.

	#>
	Param (
		[ValidateNotNull()]
		[Parameter(Mandatory=$true)]
		[System.Windows.Forms.DataGridView]$DataGridView,
		[ValidateNotNull()]
		[Parameter(Mandatory=$true)]
		$Item,
	    [Parameter(Mandatory=$false)]
		[string]$DataMember
	)
	$DataGridView.SuspendLayout()
	$DataGridView.DataMember = $DataMember
	
	if ($Item -is [System.ComponentModel.IListSource]`
	-or $Item -is [System.ComponentModel.IBindingList] -or $Item -is [System.ComponentModel.IBindingListView] )
	{
		$DataGridView.DataSource = $Item
	}
	else
	{
		$array = New-Object System.Collections.ArrayList
		
		if ($Item -is [System.Collections.IList])
		{
			$array.AddRange($Item)
		}
		else
		{	
			$array.Add($Item)	
		}
		$DataGridView.DataSource = $array
	}
	
	$DataGridView.ResumeLayout()
}

function ConvertTo-DataTable
{
	<#
		.SYNOPSIS
			Converts objects into a DataTable.
	
		.DESCRIPTION
			Converts objects into a DataTable, which are used for DataBinding.
	
		.PARAMETER  InputObject
			The input to convert into a DataTable.
	
		.PARAMETER  Table
			The DataTable you wish to load the input into.
	
		.PARAMETER RetainColumns
			This switch tells the function to keep the DataTable's existing columns.
		
		.PARAMETER FilterWMIProperties
			This switch removes WMI properties that start with an underline.
	
		.EXAMPLE
			$DataTable = ConvertTo-DataTable -InputObject (Get-Process)
	#>
	[OutputType([System.Data.DataTable])]
	param(
	[ValidateNotNull()]
	$InputObject, 
	[ValidateNotNull()]
	[System.Data.DataTable]$Table,
	[switch]$RetainColumns,
	[switch]$FilterWMIProperties)
	
	if($Table -eq $null)
	{
		$Table = New-Object System.Data.DataTable
	}

	if($InputObject-is [System.Data.DataTable])
	{
		$Table = $InputObject
	}
	else
	{
		if(-not $RetainColumns -or $Table.Columns.Count -eq 0)
		{
			#Clear out the Table Contents
			$Table.Clear()

			if($InputObject -eq $null){ return } #Empty Data
			
			$object = $null
			#find the first non null value
			foreach($item in $InputObject)
			{
				if($item -ne $null)
				{
					$object = $item
					break	
				}
			}

			if($object -eq $null) { return } #All null then empty
			
			#Get all the properties in order to create the columns
			foreach ($prop in $object.PSObject.Get_Properties())
			{
				if(-not $FilterWMIProperties -or -not $prop.Name.StartsWith('__'))#filter out WMI properties
				{
					#Get the type from the Definition string
					$type = $null
					
					if($prop.Value -ne $null)
					{
						try{ $type = $prop.Value.GetType() } catch {}
					}

					if($type -ne $null) # -and [System.Type]::GetTypeCode($type) -ne 'Object')
					{
		      			[void]$table.Columns.Add($prop.Name, $type) 
					}
					else #Type info not found
					{ 
						[void]$table.Columns.Add($prop.Name) 	
					}
				}
		    }
			
			if($object -is [System.Data.DataRow])
			{
				foreach($item in $InputObject)
				{	
					$Table.Rows.Add($item)
				}
				return  @(,$Table)
			}
		}
		else
		{
			$Table.Rows.Clear()	
		}
		
		foreach($item in $InputObject)
		{		
			if($item)
			{
				$row = $table.NewRow()
				foreach ($prop in $item.PSObject.Get_Properties())
				{
					if($table.Columns.Contains($prop.Name))
					{
						# Fix for the annoying DBNull error...
						if ($prop.Value) {
							$row.Item($prop.Name) = $prop.Value
						}
						else {
							$row.Item($prop.Name) = [System.DBNull]::Value
						}							
					}
				}
				[void]$table.Rows.Add($row)
			}
		}
	}

	return @(,$Table)	
}
#endregion


$FormEvent_Load={
	$comboboxResourceType.SelectedIndex = 0
	
	# Set default date range to the past 7 days
	$dtpMin.Value = (Get-Date).AddDays(-7)
	$dtpMax.Value = Get-Date
	if (!$DDC) {
		$DDC = 'ctxddc01'
	}
	$script:ctxEnumLookup = New-Object PSObject
	$script:ctxEnums      = Get-CtxMonitorEnumerator -DDC $DDC | Sort-Object -Unique
	foreach ($ctxEnum in $ctxEnums) {
		$script:ctxEnumLookup | Add-Member -MemberType 'NoteProperty' -Name $ctxEnum -Value $(Get-CtxMonitorEnumerator -DDC $DDC -DataType $ctxEnum)
	}
	$script:FormLoaded = $true
	Refresh-Form
}

$buttonRefresh_Click={
	Refresh-Form
}

$buttonSearch_Click={
	Refresh-Form
}

$datagridviewResults_ColumnHeaderMouseClick=[System.Windows.Forms.DataGridViewCellMouseEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellMouseEventArgs]
	if ($_.Button -eq 'Right') {
		$script:columnIndex = $_.ColumnIndex
		$contextmenustripGridview.Show([System.Windows.Forms.Cursor]::Position)
	}
	elseif($datagridviewResults.DataSource -is [System.Data.DataTable])
	{
		$column = $datagridviewResults.Columns[$_.ColumnIndex]
		$direction = [System.ComponentModel.ListSortDirection]::Ascending
		
		if($column.HeaderCell.SortGlyphDirection -eq 'Descending')
		{
			$direction = [System.ComponentModel.ListSortDirection]::Descending
		}

		$datagridviewResults.Sort($datagridviewResults.Columns[$_.ColumnIndex], $direction)
	}
}

$checkboxFullDetails_CheckedChanged={
	Update-TableLayout	
}

$hideToolStripMenuItem_Click={
	$datagridviewResults.Columns[$columnIndex].Visible = $false
}

$showAllToolStripMenuItem_Click={
	Update-TableLayout
}

$textboxSearch_KeyPress=[System.Windows.Forms.KeyPressEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.KeyPressEventArgs]
	#TODO: Place custom script here
	if ($_.KeyChar -eq [System.Windows.Forms.Keys]::Enter) {
		Refresh-Form
	}
}

$comboboxOperator_SelectedIndexChanged={
	if (($comboboxOperator.SelectedItem -eq 'contains') -and $script:needScopeWarning) {
		if ([System.Windows.Forms.MessageBox]::Show("The 'contains' operator is experimental, and will not attempt to parse comma-separated search strings. Enable ambiguous search?", 'Enable Ambiguous Search?', 'YesNo', 'Warning', 'Button2') -ne 'Yes') {
			$comboboxOperator.SelectedItem = 'equals'
		} else {
			$script:needScopeWarning = $false
		}
	}
}

$buttonExportCSV_Click={
	if ($savefiledialogCsv.ShowDialog() -eq 'OK') {
		try {
			$script:connectionLogs | Export-Csv -NoTypeInformation -Path $savefiledialogCsv.FileName -ErrorAction 'Stop'
			$exportError = $false
		}
		catch {
			$exportError = $true
			throw $_
			$statusbarMain.Text = "Error exporting results to '$($savefiledialogCsv.FileName)'. $($_.Exception.Message)"
		}
		if (!$exportError) {
			[System.Windows.Forms.Clipboard]::SetText($savefiledialogCsv.FileName)
			$statusbarMain.Text = "Exported results to '$($savefiledialogCsv.FileName)' (path copied to clipboard)"
		}
	}
}

$buttonCancelSearch_Click={
	$buttonCancelSearch.Enabled = $false
	$statusbarMain.Text = "Cancelling search..."
	$script:cancelSearch = $true
}

$webInterfaceToolStripMenuItem_Click={
	$comboboxOperator.SelectedItem = 'equals'
	$comboboxSearchTarget.SelectedItem = 'LaunchedViaIPAddress'
	$textboxSearch.Text = '10.20.66.231, 10.20.68.104, 10.160.2.7, 10.160.3.251'
}

$storeFront25ToolStripMenuItem_Click={
	$comboboxOperator.SelectedItem = 'equals'
	$comboboxSearchTarget.SelectedItem = 'LaunchedViaIPAddress'
	$textboxSearch.Text = '10.20.64.80, 10.20.64.142, 10.160.0.129, 10.160.0.130'
}

$storeFront26ToolStripMenuItem_Click={
	$comboboxOperator.SelectedItem = 'equals'
	$comboboxSearchTarget.SelectedItem = 'LaunchedViaIPAddress'
	$textboxSearch.Text = '10.20.68.21, 10.20.68.22, 10.20.68.23, 10.160.3.21, 10.160.3.22, 10.160.3.23'
}
